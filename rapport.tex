\documentclass[titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{caption} 
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tabularx}
\usepackage{colortbl}
\usepackage{mathbbol}
\usepackage{amssymb}
\usepackage{amsfonts}


\title{Rapport MT10 - TP3 : Corps finis et corps correcteurs}
\author{Océane Bordeau, Martin Schneider}
\date{10 mai 2022}

\setlength{\parindent}{0pt}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{gray}{rgb}{0.8,0.8,0.8}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{codeblue}{rgb}{0,0,255}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{ 
    commentstyle=\color{magenta},
    keywordstyle=\color{codeblue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}
    \maketitle
    \tableofcontents
    \pagebreak

    \section{Construction de corps finis}
        \setcounter{subsection}{2}
        \subsection{Dénombrement des polynômes irréductibles et unitaires de $\mathbb{F}_p[X]$}
            \subsubsection{Factorisation de $X^q-X$ dans $\mathbb{F}_p[X]$}
            Question 1
            \subsubsection{La fonction de Möbius}
            Question 2

            1.
            % \lstinputlisting[language=Python, firstline=1, lastline=5]{utils.sage.py}
            2.
            % \lstinputlisting[language=Python, firstline=7, lastline=17]{utils.sage.py}
            3.
            % \lstinputlisting[language=Python, firstline=19, lastline=25]{utils.sage.py}
            \subsubsection{Calcul du nombre de polynômes unitaires irréductibles de degré $d$ dans $\mathbb{F}_p[X]$}
            Question 3
            % \lstinputlisting[language=Python, firstline=27, lastline=33]{utils.sage.py}
            Question 4
            % \lstinputlisting[language=Python, firstline=35, lastline=45]{utils.sage.py}
        \subsection{Calcul de polynômes unitaires irréductibles de $\mathbb{F}_p[X]$}
    
    \section{Les codes de Reed et Solomon}

        \subsection{Définition des codes de Reed-Solomon généralisés (GRS)}

        \textbf{Question 5 :}
        La fonction \texttt{codeGRS} prend en entrée un bloc d'entiers $message$ de longueur $k$, et les paramètres $v$ et $\alpha$ de longueur $n$.
        On associera chaque entier de $message$ avec un élément dans $\mathbb{F}_q$. Les entiers doivent donc être inférieurs à $q$.
        Par définition, on a $0 \leqslant k \leqslant n \leqslant q$. La fonction retourne $y = ev_{\alpha,v}(f) = (v_0f(\alpha_0), v_1f(\alpha_1), ..., v_{n-1}f(\alpha_{n-1}))$.

        Les paramètres $v$ et $\alpha$ sont des listes d'éléments tirés au hasard dans $\mathbb{F}_q$.

        \lstinputlisting[language=Python, firstline=1, lastline=8]{utils.sage.py}

        \begin{tabularx}{12cm}{|p{0.60cm}|X|}
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{q = 2**8\newline
            Fq = GF(q, name='a')\newline
            R.<X> = Fq['X']\newline
            C = Fq.list()\newline
            n, k = 8, 3\newline
            \newline
            x = [254, 20, 11]\newline
            \newline
            V = []\newline
            for i in range(n):\newline
            V.append(C[randint(1, len(C)-1)])\newline
            \newline
            A = []\newline
            for i in range(n): \newline
            \_\_ c = C[randint(1, len(C)-1)]\newline
            \_\_ while c in A:
            c = C[randint(1, len(C)-1)]\newline
            a.append(c)}
            \\
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{y = codeGRS(x, V, A)\newline
            y}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{$[a^6 + a^4 + a^2,\newline
            a^5 + a^4 + a^3 + a^2 + a + 1,\newline
            a^5 + a^3,\newline
            a^5 + a^4 + a + 1,\newline
            a^6 + a^3 + a^2,\newline
            a^7 + a^5 + a^4 + a^3,\newline
            a^5,\newline
            a^7 + a^4 + a^3 + a + 1]$}
            \\
            \hline
        \end{tabularx}
        \bigbreak

        \subsection{Cas sans erreur : décodage des GRS par interpolation de Lagrange}
        \textbf{Question 6 :}
        Grâce à l'interpolation de Lagrange qui permet de reconstruire un polynome avec plusieurs valeurs de $x$ et $y$ données. 
        On peut retrouver le message du départ à partir du message encodé.

        Le polynome est défini par :
        \[\sum_{i=0}^{n-1}y_il_i(X)\]
        avec :
        \[l_i(X) = \prod_{j = 0; j \neq i}^{n - 1}\frac{X-x_j}{x_i-x_j} \]

        Ici on trouve $y_j$ grâce au message encodé, en effet : 
        \[y_i = f(\alpha_i) = \frac{v_i}{messageEncode[i]}\]

        \lstinputlisting[language=Python, firstline=10, lastline=26]{utils.sage.py}

        \begin{tabularx}{12cm}{|p{0.60cm}|X|}
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{decodeGRS(y, V, A)}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{[254, 20, 11]}
            \\
            \hline
        \end{tabularx}
        \bigbreak

        Si on ne choisit pas les point $\alpha_i$ distincts deux à deux, on risque de diviser par 0 à un moment donné dans le polynôme de Lagrange.

        \subsection{Simulation d’erreurs de transmission}
        \textbf{Question 7 :}
        Chaque mot codé $y$ est envoyé par un canal de transmission, il se peut que d'éventuelles erreurs font que nous recevons un mot codé $y'$ différent.
        On cherche à simuler des erreurs de transmission avec la fonction \texttt{errTrans} qui prend en paramètre $y$ le mot codé, et $Nb\_err$ le nombre d'erreurs de transmissions.
        On tire aléatoirement chaque erreur dans $\mathbb{F}_q^*$. La fonction retourne $y'$ le mot codé avec $Nb\_err$ de transmission.

        \lstinputlisting[language=Python, firstline=28, lastline=34]{utils.sage.py}

        \begin{tabularx}{12cm}{|p{0.60cm}|X|}
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{yp = errTrans(y, 2)\newline
            y\newline
            yp}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{$[a^6 + a^4 + a^2,\newline
            a^5 + a^4 + a^3 + a^2 + a + 1,\newline
            a^5 + a^3,\newline
            a^5 + a^4 + a + 1,\newline
            a^6 + a^3 + a^2,\newline
            a^7 + a^5 + a^4 + a^3,\newline
            a^5,\newline
            a^7 + a^4 + a^3 + a + 1]$\newline\newline
            $[a^6 + a^4 + a^2,\newline
            a^5 + a^4 + a^3 + a^2 + a + 1,\newline
            a^5 + a^2 + a,\newline
            a^7 + a^6 + a^5 + a^3 + a + 1,\newline
            a^6 + a^3 + a^2,\newline
            a^6 + a^5 + a^4 + a^3 + a^2 + 1,\newline
            a^5,\newline
            a^7 + a^4 + a^3 + a + 1]$}
            \\
            \hline
        \end{tabularx}
        \bigbreak

        \textbf{Question 8 :}
        On vérifie que l'interpolation de Lagrange donne n'importe quoi dès qu'il y a une erreur de transmission.

        \begin{tabularx}{12cm}{|p{0.60cm}|X|}
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{decodeGRS(y, V, A)}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{[254, 20, 11]}
            \\
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{decodeGRS(yp, V, A)}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{[168, 245, 225, 26, 148, 173, 42, 243]}
            \\
            \hline
        \end{tabularx}
        \bigbreak

    \section{Correction d’erreurs grâce aux GRS}
        \subsection{Le polynôme syndrome}
        \textbf{Question 9 :}
        On peut calculer le polynôme syndrome avec les paramètres $y'$ le mot reçu, les vecteurs $v$ et $\alpha$.
        On définit $r$ par $r = n - k$.

        Le polynome syndrome est définit par : 
        \[S_{y'}(X) = \sum_{i = 0}^{n - 1}y'_i(v_i^{-1}L_i(\alpha_i)^{-1})(\sum_{j = 0}^{r - 1}(\alpha_iX)^j)\]

        Si $S(X) = 0$, on a donc $y' \in GRS_{n,k}(\alpha,v)$ et on a alors de grandes chances pour que $y'$ ne contienne pas d'erreurs.

        \lstinputlisting[language=Python, firstline=36, lastline=41]{utils.sage.py}

        \textbf{Question 10 :}\bigbreak

        \begin{tabularx}{12cm}{|p{0.60cm}|X|}
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{print(f"S(X) = \{Syndrome(y, A, V)\}")}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{$S(X) = 0$}
            \\
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{print(f"S(X) = \{Syndrome(yp, A, V)\}")}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{$S(X) = (a^4 + a^2 + a + 1)*X^4 + (a^6 + a^2 + a + 1)*X^3 + (a^5 + a^4 + a^3 + a^2 + a)*X^2 + a^3*X + a^6 + a^5 + a^4 + a^3 + a^2 + 1$}
            \\
            \hline
        \end{tabularx}
        \bigbreak

        On a bien $y' \in C \Longleftrightarrow S(X) = 0$.

        \subsection{L’équation clef}
        L'équation clef est la suivante : 
        \[\sigma(X)S(X) = \omega(X) [X^r]\]
        avec le polynôme localisateur des erreurs $\sigma(X)$ et le polynôme évaluateur des erreurs $\omega(X)$.

        \subsection{Résolution de l’équation clef par Euclide}
        
        \textbf{Question 11 :}
        Grâce à l'algorithme d'Euclide on peut trouver $\sigma$ et $\omega$, la fonction \texttt{Clef} 
        calcule à partir du polynôme syndrome $S(X)$, de $q$, $k$ et $n$, les polynômes $\sigma$ et $\omega$.

        \lstinputlisting[language=Python, firstline=43, lastline=57]{utils.sage.py}
        
        Avec l'exemple développé jusqu'ici on vérifie que l'équation clef est satisfaite.

        \begin{tabularx}{12cm}{|p{0.60cm}|X|}
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{r = n - k\newline
            S = Syndrome(yp, a, v)\newline
            sigma, omega = Clef(S)\newline
            print(sigma)
            print(omega)}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{$(a^7 + a^6 + a^5 + a^3 + a)*X^2 + (a^6 + a^5 + a^4 + a^3 + a^2 + 1)*X + 1\newline\newline
            (a^7 + a^2 + 1)*X^2 + (a^7 + a^6 + a^5 + a^4 + a^3 + a^2 + 1)*X + a^6 + a^5 + a^4 + a^3 + a^2 + 1$}
            \\
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{print(((sigma * R(S)) \% X**r) == (omega\% X**r))}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{True}
            \\
            \hline
        \end{tabularx}
        \bigbreak

        \subsection{Localisation et évaluation des erreurs de transmission}
        \textbf{Question 12 :}
        La fonction \texttt{Erreur} à partir des polynômes localisateur et évaluateur $\sigma$ et $\omega$, et des vecteurs $v$ et $\alpha$,
        retourne un tableau $e$ correspondant à l'erreur de transmission.

        On peut calculer $e_b$ de la façon suivante : 
        \[e_b = -\alpha_b*\omega(\alpha_b^{-1})*v_b*L_b(\alpha_b)*(\sigma'(\alpha_b^{-1}))^{-1}\]
        en sachant que : 
        \[B = \{b \in [0,n-1] : \sigma(\alpha_b^{-1}) = 0 \}\]

        \lstinputlisting[language=Python, firstline=59, lastline=67]{utils.sage.py}

        \begin{tabularx}{12cm}{|p{0.60cm}|X|}
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{e = Erreur(sigma, omega, A, V)\newline
            yc = [i-j for i, j in zip(yp, e)]\newline
            decodeGRS(yc, V, A)}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{[254, 20, 11]}
            \\
            \hline
        \end{tabularx}
        \bigbreak

    \section{Conclusion : une chaîne de transmission cryptée robuste}

\end{document}