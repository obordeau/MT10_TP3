\documentclass[titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{caption} 
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tabularx}
\usepackage{colortbl}
\usepackage{mathbbol}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}


\title{Rapport MT10 - TP3 : Corps finis et corps correcteurs}
\author{Océane Bordeau, Martin Schneider}
\date{10 mai 2022}

\setlength{\parindent}{0pt}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{gray}{rgb}{0.8,0.8,0.8}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{codeblue}{rgb}{0,0,255}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{ 
    commentstyle=\color{magenta},
    keywordstyle=\color{codeblue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}
    \maketitle
    \tableofcontents
    \pagebreak

    \section{Construction de corps finis}
        \setcounter{subsection}{2}
        \subsection{Dénombrement des polynômes irréductibles et unitaires de $\mathbb{F}_p[X]$}
            \subsubsection{Factorisation de $X^q-X$ dans $\mathbb{F}_p[X]$}
            \textbf{Question 1 :}

            L'objetcif est de vérifier la factorisation du pôlynome $X^q-X$ avec $q=2^6$.

            Pour cela, nous allons déterminer l'ensemble des pôlynomes unitaires et irréductibales de degré $d$ tels que $d|n$, puis effectuer leur produit.

            \lstinputlisting[language=Python, firstline=101, lastline=109]{utils.sage.py}

            \begin{tabularx}{12cm}{|p{0.60cm}|X|}
                \hline
                \rowcolor{gray}
                \texttt{In}
                & 
                \texttt{prod == R(x ** (p ** n) - x)}
                \\
                \hline
                \texttt{Out}
                &
                \texttt{True}
                \\
                \hline
            \end{tabularx}
            \bigbreak

            On peut donc affirmer :

            \[ X^q-X=\prod_{\substack{P \in \mathbb{F}_p[X] \\ irr\acute{e}ductible \: et \: unitaire  \\ deg(P)|n}} P(X) \]

            \subsubsection{La fonction de Möbius}
            \textbf{Question 2 :}

            \lstinputlisting[language=Python, firstline=55, lastline=59]{utils.sage.py}

            \begin{tabularx}{12cm}{|p{0.60cm}|X|}
                \hline
                \rowcolor{gray}
                \texttt{In}
                & 
                \texttt{test1(100)}
                \\
                \hline
                \texttt{Out}
                &
                \texttt{True}
                \\
                \hline
            \end{tabularx}
            \bigbreak

            On vérifie donc que $\mu (n) \in \{-1;0;1\}$ pour les 100 premiers entiers naturels.

            \lstinputlisting[language=Python, firstline=61, lastline=68]{utils.sage.py}

            \begin{tabularx}{12cm}{|p{0.60cm}|X|}
                \hline
                \rowcolor{gray}
                \texttt{In}
                & 
                \texttt{test2(100)}
                \\
                \hline
                \texttt{Out}
                &
                \texttt{True}
                \\
                \hline
            \end{tabularx}
            \bigbreak

            La formule d'Euler est vérifiée pour les 100 premiers entiers naturels.

            \lstinputlisting[language=Python, firstline=70, lastline=74]{utils.sage.py}

            \begin{tabularx}{12cm}{|p{0.60cm}|X|}
                \hline
                \rowcolor{gray}
                \texttt{In}
                & 
                \texttt{phiMobius(100)}
                \\
                \hline
                \texttt{Out}
                &
                \texttt{40}
                \\
                \hline
            \end{tabularx}
            \bigbreak

            \begin{tabularx}{12cm}{|p{0.60cm}|X|}
                \hline
                \rowcolor{gray}
                \texttt{In}
                & 
                \texttt{euler\_phi(100)}
                \\
                \hline
                \texttt{Out}
                &
                \texttt{40}
                \\
                \hline
            \end{tabularx}
            \bigbreak

            Le calcul de $\phi (100)$ grâce à la formule d'inversion de Möbius donne bien le bon résultat : $40$.

            \subsubsection{Calcul du nombre de polynômes unitaires irréductibles de degré $d$ dans $\mathbb{F}_p[X]$}
            \textbf{Question 3 :}
            \lstinputlisting[language=Python, firstline=76, lastline=80]{utils.sage.py}
            Grâce à ctte fonction, dressons un tableau de $Irr_p(n)$ pour $p = 2, 3, 5$ et $n = 1, . . . , 10$.

            \begin{tabular}{|c|c c c c c c c c c c|}
                \hline
                & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
                \hline
                2 & 2 & 1 & 2 & 3 & 6 & 9 & 18 & 30 & 56 & 99 \\
                3 & 3 & 3 & 8 & 18 & 48 & 116 & 312 & 810 & 2184 & 5880 \\
                5 & 5 & 10 & 40 & 150 & 624 & 2580 & 11160 &  48750 & 217000 & 976248 \\ 
                \hline
            \end{tabular}
            \bigbreak

            \textbf{Question 4 :}
            \lstinputlisting[language=Python, firstline=82, lastline=99]{utils.sage.py}

            \begin{tabularx}{12cm}{|p{0.60cm}|X|}
                \hline
                \rowcolor{gray}
                \texttt{In}
                & 
                \texttt{polynomes10()}
                \\
                \hline
                \texttt{Out}
                &
                \texttt{226}
                \\
                \hline
            \end{tabularx}
            \bigbreak

        \subsection{Calcul de polynômes unitaires irréductibles de $\mathbb{F}_p[X]$}
    
    \section{Les codes de Reed et Solomon}
        \subsection{Définition des codes de Reed-Solomon \\ généralisés (GRS)}

        \textbf{Question 5 :}
        La fonction \texttt{codeGRS} prend en entrée un bloc d'entiers $message$ de longueur $k$, et les paramètres $v$ et $\alpha$ de longueur $n$.
        On associera chaque entier de $message$ avec un élément dans $\mathbb{F}_q$. Les entiers doivent donc être inférieurs à $q$.
        Par définition, on a $0 \leqslant k \leqslant n \leqslant q$. La fonction retourne $y = ev_{\alpha,v}(f) = (v_0f(\alpha_0), v_1f(\alpha_1), ..., v_{n-1}f(\alpha_{n-1}))$.

        Les paramètres $v$ et $\alpha$ sont des listes d'éléments tirés au hasard dans $\mathbb{F}_q$.

        \lstinputlisting[language=Python, firstline=1, lastline=8]{utils.sage.py}

        \begin{tabularx}{12cm}{|p{0.60cm}|X|}
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{q = 2**8\newline
            Fq = GF(q, name='a')\newline
            R.<X> = Fq['X']\newline
            C = Fq.list()\newline
            n, k = 8, 3\newline
            \newline
            x = [254, 20, 11]\newline
            \newline
            V = []\newline
            for i in range(n):\newline
            V.append(C[randint(1, len(C)-1)])\newline
            \newline
            A = []\newline
            for i in range(n): \newline
            \_\_ c = C[randint(1, len(C)-1)]\newline
            \_\_ while c in A:
            c = C[randint(1, len(C)-1)]\newline
            a.append(c)}
            \\
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{y = codeGRS(x, V, A)\newline
            y}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{$[a^7 + a^5 + a^4 + a^3 + 1, \newline
            a^5 + a^4 + a^3 + a^2 + 1,\newline
            a^6 + a^3 + a^2,\newline
            a^7 + a^6 + a^2 + a + 1,\newline
            a^6 + a^5 + a^3 + a^2,\newline
            a^3 + a^2 + a + 1,\newline
            a^6 + a^5 + a^2 + a,\newline
            a^5 + a^2]$}
            \\
            \hline
        \end{tabularx}
        \bigbreak

        \subsection{Cas sans erreur : décodage des GRS par interpolation de Lagrange}
        \textbf{Question 6 :}
        Grâce à l'interpolation de Lagrange qui permet de reconstruire un polynome avec plusieurs valeurs de $x$ et $y$ données. 
        On peut retrouver le message du départ à partir du message encodé.

        Le polynome est défini par :
        \[\sum_{i=0}^{n-1}y_il_i(X)\]
        avec :
        \[l_i(X) = \prod_{j = 0; j \neq i}^{n - 1}\frac{X-x_j}{x_i-x_j} \]

        Ici on trouve $y_j$ grâce au message encodé, en effet : 
        \[y_i = f(\alpha_i) = \frac{v_i}{messageEncode[i]}\]

        \lstinputlisting[language=Python, firstline=14, lastline=31]{utils.sage.py}

        \begin{tabularx}{12cm}{|p{0.60cm}|X|}
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{decodeGRS(211, messageEncode, V, A)}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{[2, 8, 6, 4, 9, 10, 7]}
            \\
            \hline
        \end{tabularx}
        \bigbreak

        Si on ne choisit pas les point $\alpha_i$ distincts deux à deux, on risque de diviser par 0 à un moment donné dans le polynôme de Lagrange.

        \subsection{Simulation d’erreurs de transmission}
        \textbf{Question 7 :}
        Chaque mot codé $y$ est envoyé par un canal de transmission, il se peut que d'éventuelles erreurs font que nous recevons un mot codé $y'$ différent.
        On cherche à simuler des erreurs de transmission avec la fonction \texttt{errTrans} qui prend en paramètre $y$ le mot codé, et $Nb\_err$ le nombre d'erreurs de transmissions.
        On tire aléatoirement chaque erreur dans $\mathbb{F}_q^*$. La fonction retourne $y'$ le mot codé avec $Nb\_err$ de transmission.

        \lstinputlisting[language=Python, firstline=33, lastline=40]{utils.sage.py}

        \begin{tabularx}{12cm}{|p{0.60cm}|X|}
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{messageErreur = errTrans(211, messageEncode, 3) \newline
            messageEncode \newline
            messageErreur}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{[157, 96, 201, 79, 206, 49, 187, 143, 107, 133]\newline
            [157, 86, 49, 79, 206, 49, 187, 32, 107, 133]}
            \\
            \hline
        \end{tabularx}
        \bigbreak

        \textbf{Question 8 :}
        On vérifie que l'interpolation de Lagrange donne n'importe quoi dès qu'il y a une erreur de transmission.

        \begin{tabularx}{12cm}{|p{0.60cm}|X|}
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{decodeGRS(211, messageEncode, V, A)}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{[2, 8, 6, 4, 9, 10, 7]}
            \\
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{decodeGRS(211, messageErreur, V, A)}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{[18, 112, 184, 168, 33, 76, 147, 9, 119, 24]}
            \\
            \hline
        \end{tabularx}
        \bigbreak

    \section{Correction d’erreurs grâce aux GRS}
        \subsection{Le polynôme syndrome}
        \textbf{Question 9 :}
        On peut calculer le polynôme syndrome avec les paramètres $y'$ le mot reçu, les vecteurs $v$ et $\alpha$, 
        et les longueurs $n$ (longueur des vecteurs $v$ et $\alpha$) et $k$, la longueur du mot à transmettre au départ. 
        On définit $r$ par $r = n - k$.

        Le polynome syndrome est définit par : 
        \[S_{y'}(X) = \sum_{i = 0}^{n - 1}y'_i(v_i^{-1}L_i(\alpha_i)^{-1})(\sum_{j = 0}^{r - 1}(\alpha_iX)^j)\]

        Si $S(X) = 0$, on a donc $y' \in GRS_{n,k}(\alpha,v)$ et on a alors de grandes chances pour que $y'$ ne contienne pas d'erreurs.

        \lstinputlisting[language=Python, firstline=42, lastline=53]{utils.sage.py}

        \textbf{Question 10 :}\bigbreak

        \begin{tabularx}{12cm}{|p{0.60cm}|X|}
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{print(f"S(X) = \{Syndrome(211, len(message), \newline
            messageEncode, V, A)\}")}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{$S(X) = 0$}
            \\
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{print(f"S(X) = \{Syndrome(211, len(message), \newline
            messageErreur, V, A)\}")}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{$S(X) = 67*X^2 + 120*X + 18$}
            \\
            \hline
        \end{tabularx}
        \bigbreak

        On a bien $y' \in C \Longleftrightarrow S(X) = 0$.

        \subsection{L’équation clef}
        L'équation clef est la suivante : 
        \[\sigma(X)S(X) = \omega(X) [X^r]\]
        avec le polynôme localisateur des erreurs $\sigma(X)$ et le polynôme évaluateur des erreurs $\omega(X)$.

        \subsection{Résolution de l’équation clef par Euclide}
        
        \textbf{Question 11 :}
        Grâce à l'algorithme d'Euclide on peut trouver $\sigma$ et $\omega$, la fonction \texttt{Clef} 
        calcule à partir du polynôme syndrome $S(X)$, de $q$, $k$ et $n$, les polynômes $\sigma$ et $\omega$.

        \lstinputlisting[language=Python, firstline=55, lastline=79]{utils.sage.py}
        
        Avec l'exemple développé jusqu'ici on vérifie que l'équation clef est satisfaite.

        \begin{tabularx}{12cm}{|p{0.60cm}|X|}
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{syndromeErreur = Syndrome(211, len(message), \newline
            messageErreur, V, A) \newline
            sigma, omega = clef(211, syndromeErreur, len(message), len(V)) \newline
            print(f"sigma = \{sigma\}") \newline
            print(f"omega = \{omega\}")}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{sigma = 170*X + 1 \newline
            omega = 15*X + 18}
            \\
            \hline
            \rowcolor{gray}
            \texttt{In}
            & 
            \texttt{FqX.<X> = GF(211)['X'] \newline
            r = len(V) - len(message) \newline
            print(f"\{(sigma * FqX(syndromeErreur)) \% X**r\} = \{omega \% X**r\} ?")}
            \\
            \hline
            \texttt{Out}
            &
            \texttt{15*X + 18 = 15*X + 18 ?}
            \\
            \hline
        \end{tabularx}
        \bigbreak

        \subsection{Localisation et évaluation des erreurs de transmission}
    \section{Conclusion : une chaîne de transmission cryptée robuste}

\end{document}